1. 자료구조
    1) 대량의 데이터를 효율적으로 관리하는 메커니즘을 자료구조라 함
        - 우편번호, 학번 
            - 예) 무작위 명단 
                 -무작위로 나열된 명단에서 특정 학생을 찾는 것은 비효율적임
            - 예) 학년, 반, 출석 번호로 관리
                - 체계적인 학생 관리를 통해 2학년 2반 30번 이순신 찾는 경우
                - 효율적으로 찾을 수 있음

    2) 배열, 리스트, 스택, 큐, 트리 등 

    3) 배열
        - 크기가 고정되어 있어 데이터를 추가하거나 삭제 할 수 없음.
            - 새로 배열을 만들고 옮겨야 함

    4) 리스트 
        - 원소가 원소를 가리켜서 관리하는 자료구조임
        - 데이터가 추가되거나 삭제될 때 연결한느 정보만 바꾸면 쉽게 추가, 삭제가 됨

    5) 스택
        - 한쪽 끝에서만 자료를 넣거나 뺄수 있는 선형 구조(LIFO, last in first out)로 되어 있음
        - 자료를 넣는 것을 밀어넣는다 하여 푸시(push)라고 하고 
        - 반대로 넣어둔 자료를 꺼내는 것을 팝(pop)이라고 함
        - 가장 최근에 푸시한 자료부터 나오게 됨   
        - 오래된 데이터가 제일 아래에 있음 ==> 맨 처음 들어온건 아래 마지막에 들어 오면 위에 .. 문이 하나)

    6) 큐
        - 먼저 집어넣은 데이터가 먼저 나오는 FIFO(First In First Out) 구조 ==>    문이 두개라서 먼저 들어가면 먼저 나옴 
        - 지하철에 줄을 선 승객들의 행렬과 같은 것임
        - 제일 먼저 쌓인 데이터가 제일 먼저 출력됨

    7) 트리
        - 부모 노드 밑에 여러 자식 노드가 연결되고,
          자식 노드 각각에 다시 자식 노드가 연결되는 형태의 자료구조    ==>  맨위에 부모가 있음 크면 오른쪽, 작으면 왼쪽, 오름차순으로 결과출력
        - 자식 노드에서 부모쪽으로 계속해서 타고 올라가다 보면 
          결국 부모가 없는 하나의 노드로 이어지게 됨 ==> 루트 노트(root node)라 함
        - 루트 노드를 중심으로 뻗어나가는 모습이 나무의 구조와 비슷함

2. 컬렉션 프레임워크
    1) 자료구조를 개발자가 편리하게 사용할 수 있도록 컬렉션 프레임워크 제공함
        - java.unit 패기키에 구현되어 있음
        - 최적화 된 알고리즘으로 구현되어 짐
        - 여러 구현 클래스와 인터페이스의 활용에 대한 이해가 필요함

    2) Interface Iterable<T> => 반복해주는 기능
                    /|\
                     |
                     |
        Interface Collection<E>                                                 Interface Map<K,V>
        - The root interface in the collection hierarchy                        - 키(Key)와 값(Value)으로 이루어진 데이터들의 집합 
             /|\                                /|\                             - 키는 중복을 허용하지 않음
              |                                  |                              - 값(Value)은 중복될 수 있음
              |                                  |                              - Class HashMap<K,V>
              |                                  |                              - Class TreeMap<K,V>
                                                                                - class Hashtable <K,V>       
        Interface List<E>           Interface Set<E>                            -class  Properties
        - 순서가 있는 데이터 집합        - 데이터의 순서가 유지되지 않음             - 객체는 Key-Value의 쌍(pair)으로 이뤄져있음
        - 추가된 데이터의 순서도 유지     - 중복된 데이터가 제거됨
        - 데이터 중복도 허용됨           - 데이터의 중복이 허용 되지 않음
        - Class ArrayList<E>            - Class HashSet<E>
        - Class LinkedList<E>           - Class TreeSet<E>   
        - Class Vector<E>               - 순서와 관계없이 유일한 값 관리
        - Class Stack<E>                - 저장된 순서와 출력되는 순서는 다를 수 있음
        - 객체를 순서에 따라 저장

3. List<E> 인터페이스를 구현하는 켈력션 클래스들 
    1) ArrayList<E>
        - 배열 기반 자료구조
        - 배열을 이용하여 객체를 저장됨     
        - 데이터의 저장 순서가 유지됨
        - 동일 데이터의 중복 저장 허용   

4. Interface Iterator<E>
    1) Collection 요소를 순회
    2) 컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조하는 것
    3) 순서가 있는 List 인터페이스의 경우는 Interator를  사용하지 않고 
       get(i) 메서드를 활용할 수 있음
    4) Set 인터페이스의 경우 get(i) 메서드가 제공되지 않으므로
       Interator를 이용하여 객체를 순화함  

    5) Inteartor 사용하기 
        -boolean hasNext()
            -이후에 요소가 더 있는지를 체크하는 메서드, 요소가 있으면 true를 반환
        - E next()
            -다음에 있는 요소를 반환       


                
